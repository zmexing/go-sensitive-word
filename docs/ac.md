# AC与DFA树对比说明文档
本文档旨在帮助开发者理解 **DFA（Deterministic Finite Automaton，确定性有限自动机）** 与 **AC（Aho-Corasick）算法** 在敏感词匹配中的实现、原理及优劣势差异，并通过可视化示意图和动画流程展示两者的匹配机制。

## 算法简介
### DFA（确定性有限自动机）
- **原理**：构建一个完全基于字符路径的树（Trie 树），每条敏感词路径独立存储。
- **特点**：
    1. 匹配严格按照字符路径进行，不使用 fail 指针。
    2. 每次匹配失败都必须从根节点重新开始。
    3. 对重复字符或相同后缀的词无法复用节点，容易导致空间冗余。
- **适用场景**：词库较小、匹配逻辑简单、对匹配速度要求不高的场景。

### AC（Aho-Corasick）算法
- **原理**：在 DFA 树基础上增加 **fail 指针** 和 **output 列表**，支持快速回溯与多词匹配。
- **特点**：
    1. fail 指针指向最长公共后缀节点，匹配失败时不必回到 root。
    2. 节点 output 列表可存储多个敏感词，实现单次扫描匹配多词。
    3. 对重复字符或后缀共享节点，节省内存，提高效率。
- **适用场景**：敏感词库较大、文本匹配频繁、需支持多词匹配和高性能的场景。

## DFA 树示意图
```mermaid
graph TD
    Root((root))
    Root --> 台["台"]

    台 --> 海["海"]

    海 --> 国["国"]
    国 -->|isLeaf| 国Leaf((叶子))

    海 --> 独["独"]
    独 --> 立["立"]
    立 -->|isLeaf| 独立Leaf((叶子))

    海 --> 总["总"]
    总 --> 统["统"]
    统 -->|isLeaf| 总统Leaf((叶子))

    海 --> 帝["帝"]
    帝 --> 国2["国"]
    国2 -->|isLeaf| 帝国Leaf1((叶子))

    台 --> 界["界"]
    界 --> 帝2["帝"]
    帝2 --> 国3["国"]
    国3 -->|isLeaf| 帝国Leaf2((叶子))
```
### 说明
- DFA 不使用 fail 指针，只按字符路径匹配。
- 相同字符或后缀不会复用节点，例如 `"帝"` 在 `"台海帝国"` 与 `"台界帝国"` 中各自独立。
- 每个敏感词结尾节点单独标记 `isLeaf`。

## AC 树示意图
### 简单示意图
```mermaid
graph TD
    Root((root))
    Root --> 台["台"]

    台 --> 海["海"]
    台 --> 界["界"]

    海 --> 国["国"]
    国 --> 国Leaf(("台海国"))

    海 --> 独["独"]
    独 --> 立["立"]
    立 --> 独立Leaf(("台海独立"))

    海 --> 总["总"]
    总 --> 统["统"]
    统 --> 总统Leaf(("台海总统"))

    海 --> 帝["帝"]
    帝 --> 国2["国"]
    国2 --> 帝国Leaf1(("台海帝国"))

    界 --> 帝2["帝"]
    帝2 --> 国3["国"]
    国3 --> 帝国Leaf2(("台界帝国"))

    %% fail 指针示意（虚线箭头）
    国 -.-> Root
    独 -.-> Root
    立 -.-> Root
    总 -.-> Root
    统 -.-> Root
    帝 -.-> Root
    国2 -.-> Root
    界 -.-> Root
    帝2 -.-> Root
    国3 -.-> Root
```

### 复杂完整示意图
```mermaid
graph TD
    %% 根节点
    Root((root))
    
    %% 第一层
    Root --> 台["台\noutput:[]\nfail:root"]
    Root --> 界["界\noutput:[]\nfail:root"]

    %% 第二层
    台 --> 海["海\noutput:[]\nfail:root"]
    
    %% 第三层 - 台海开头的敏感词
    海 --> 国["国\noutput:['台海国']\nfail:root"]
    海 --> 独["独\noutput:[]\nfail:root"]
    海 --> 总["总\noutput:[]\nfail:root"]
    海 --> 帝["帝\noutput:[]\nfail:root"]

    %% 第四层
    独 --> 立["立\noutput:['台海独立']\nfail:root"]
    总 --> 统["统\noutput:['台海总统']\nfail:root"]
    帝 --> 国2["国\noutput:['台海帝国']\nfail:root"]

    %% 第三层 - 台界开头
    界 --> 帝2["帝\noutput:[]\nfail:帝"]
    帝2 --> 国3["国\noutput:['台界帝国']\nfail:国2"]

    %% fail 指针虚线表示
    国 -.-> Root
    独 -.-> Root
    立 -.-> Root
    总 -.-> Root
    统 -.-> Root
    帝 -.-> Root
    国2 -.-> Root
    界 -.-> Root
    帝2 -.-> 帝
    国3 -.-> 国2
```

### 说明
- 每个节点增加 `fail` 指针，指向最长公共后缀。
- 叶子节点 `output` 列表记录敏感词，实现多词匹配。
- 相同后缀或字符可复用 fail 指针，例如 `"台界帝国"` 的 fail 指向 `"台海帝国"`。


## AC（Aho-Corasick）算法的敏感词匹配流程
### AC 树构建回顾
AC 树由以下部分组成：
1. **节点 `children`**：表示字符路径。
2. **节点 `output`**：存储匹配到的敏感词（仅叶子节点可为空或非空）。
3. **节点 `fail`**：失败回溯指针，用于当匹配失败时，跳转到最长后缀节点继续匹配。

示例 AC 树简化结构如下：
```
root
├─台
│  ├─海
│  │  ├─国 (output: 台海国)
│  │  ├─独
│  │  │  └─立 (output: 台海独立)
│  │  ├─总
│  │  │  └─统 (output: 台海总统)
│  │  └─帝
│  │     └─国 (output: 台海帝国)
│  └─界
│     └─帝
│        └─国 (output: 台界帝国)
```

Fail 指针示意：

- `台海国.fail = root`
- `台海独立.fail = root`
- `台界帝国.fail = 台海帝国`（最长公共后缀“帝国”）

### 匹配流程核心思想
匹配文本 `"台海总统是国家领导人"`：

1. **初始化**：
    - 当前节点 `node = root`
    - 遍历文本每个字符 `r`
2. **按字符匹配**：

#### 步骤示例
| 文本索引 | 字符 | 当前节点            | 说明                                                         |
| -------- | ---- | ------------------- | ------------------------------------------------------------ |
| 0        | 台   | root → 台           | 找到 `台` 子节点，移动到 `台`                                |
| 1        | 海   | 台 → 海             | 找到 `海` 子节点，移动到 `海`                                |
| 2        | 总   | 海                  | `海` 没有 `总` 子节点 → 使用 fail 指针回溯到 root → root 没有 `总` → 匹配失败 → 重置到 root → 从当前位置继续 |
| 2        | 总   | root → 台 → 海 → 总 | 实际 AC 算法是从 fail 回溯，找到最长后缀匹配 → 这里海节点有总子节点，移动到总 |
| 3        | 统   | 总 → 统             | 找到子节点 → 节点 output = ["台海总统"] → 匹配到敏感词       |


### 匹配步骤总结
匹配时，AC 算法遵循以下规则：
1. **遍历文本字符 `c`**：
    - 如果 `node.children[c]` 存在 → 移动到该子节点。
    - 如果不存在 → `node = node.fail`（回溯到最长可匹配后缀），再尝试匹配。
    - 重复回溯直到 `node = root` 或找到匹配路径。
2. **遇到敏感词**：
    - 当前节点 `output` 非空 → 把 `output` 中所有词加入匹配结果。
    - 继续扫描下一个字符，匹配不会中断。
3. **效率优势**：
    - 相比 DFA，AC 不会每次匹配失败都回到 root，而是通过 fail 指针快速回溯。
    - 可以同时匹配多个敏感词（节点 output 可存储多个词）。

### 示例：匹配 "台海总统" 流程
1. `node = root`
2. 遇到 `'台'` → 移动到 `台`
3. 遇到 `'海'` → 移动到 `海`
4. 遇到 `'总'` → 移动到 `总`
5. 遇到 `'统'` → 移动到 `统` → `output = ["台海总统"]` → 匹配到敏感词
6. 继续扫描下一个字符 → 若当前节点没有对应子节点 → fail 指针回溯

### AC 匹配流程动画版
```mermaid
flowchart TD
    %% 文本扫描流程
    subgraph 文本扫描["文本: 台海总统是国家领导人"]
        direction LR
        T0["台"] --> T1["海"] --> T2["总"] --> T3["统"] --> T4["是"] --> T5["国"] --> T6["家"] --> T7["领"] --> T8["导"] --> T9["人"]
    end

    %% AC 树节点状态
    subgraph AC树["AC 树节点移动及fail回溯"]
        direction TB
        Root((root))
        台["台"] 
        海["海"]
        总["总"] 
        统["统\noutput:['台海总统']"]
        %% fail 指针
        fail1 -.-> Root
        fail2 -.-> Root

        %% 树结构
        Root --> 台
        台 --> 海
        海 --> 总
        总 --> 统
    end

    %% 匹配流程箭头
    T0 -->|匹配 '台'| 台
    T1 -->|匹配 '海'| 海
    T2 -->|匹配失败 '总', fail 回溯 root| fail1
    fail1 -->|从 root 尝试 '总'| 总
    T3 -->|匹配 '统', output| 统
    统 -->|记录匹配: '台海总统'| 统
    T4 -->|匹配失败 '是', fail 回溯 root| fail2
```

#### AC匹配流程动画版特点
1. **文本扫描**：上方水平排列，按索引从左到右扫描每个字符。
2. **AC 树节点**：垂直展示节点路径（台 → 海 → 总 → 统）。
3. **匹配过程**：
    - 箭头表示从文本字符到 AC 树节点的匹配。
    - 失败时通过虚线箭头 fail 回溯到 root。
    - 到达叶子节点或 output 非空节点时，记录匹配敏感词。
4. **动画效果**（概念）：
    - 每扫描一个字符 → 节点高亮 → 匹配/回溯 → 输出结果。
    - 可以直观看到 AC 算法如何利用 fail 指针避免重复扫描。

#### 总结
- AC 匹配的核心就是 **字符路径 + fail 指针 + output 列表**。
- 匹配流程保证：
    1. 每次匹配失败不用回到 root，而是跳到最长公共后缀。
    2. 可以在单次扫描中匹配多个敏感词。
    3. 输出列表允许同时匹配重叠敏感词（例如 `"台海帝国"` 和 `"帝国"`）。

## DFA 与 AC 树对比图
```mermaid
%% DFA 与简化 AC 树对比
graph TD
    subgraph DFA
        DRoot((root))
        DRoot --> D台["台"]
        D台 --> D海["海"]
        D海 --> D国["国"]
        D国 --> D国Leaf(("叶子: 台海国"))
        D海 --> D独["独"]
        D独 --> D立["立"]
        D立 --> D独立Leaf(("叶子: 台海独立"))
        D海 --> D总["总"]
        D总 --> D统["统"]
        D统 --> D总统Leaf(("叶子: 台海总统"))
        D海 --> D帝["帝"]
        D帝 --> D国2["国"]
        D国2 --> D帝国Leaf1(("叶子: 台海帝国"))
        D台 --> D界["界"]
        D界 --> D帝2["帝"]
        D帝2 --> D国3["国"]
        D国3 --> D帝国Leaf2(("叶子: 台界帝国"))
    end

    subgraph AC
        Root((root))
        Root --> 台["台"]
        台 --> 海["海"]
        台 --> 界["界"]
        海 --> 国["国"]
        国 --> 国Leaf(("台海国"))
        海 --> 独["独"]
        独 --> 立["立"]
        立 --> 独立Leaf(("台海独立"))
        海 --> 总["总"]
        总 --> 统["统"]
        统 --> 总统Leaf(("台海总统"))
        海 --> 帝["帝"]
        帝 --> 国2["国"]
        国2 --> 帝国Leaf1(("台海帝国"))
        界 --> 帝2["帝"]
        帝2 --> 国3["国"]
        国3 --> 帝国Leaf2(("台界帝国"))
        %% fail 指针虚线
        国 -.-> Root
        独 -.-> Root
        立 -.-> Root
        总 -.-> Root
        统 -.-> Root
        帝 -.-> Root
        国2 -.-> Root
        界 -.-> Root
        帝2 -.-> Root
        国3 -.-> Root
    end
```

### 对比说明
| 特性      | DFA                       | AC（Aho-Corasick）           |
| --------- | ------------------------- | ---------------------------- |
| 路径复用  | 无，重复字符/后缀独立节点 | 有，相同后缀可复用 fail 指针 |
| fail 指针 | 无                        | 有，匹配失败快速回溯         |
| 匹配效率  | 匹配失败回 root，效率低   | fail 指针减少回溯，效率高    |
| 多词匹配  | 不支持                    | 支持，output 列表存储多个词  |

## AC vs DFA 匹配动画对比图
```mermaid
flowchart TB
    %% 文本扫描
    subgraph 文本["文本: 台海总统是国家领导人"]
        direction LR
        T0["台"] --> T1["海"] --> T2["总"] --> T3["统"] --> T4["是"] --> T5["国"] --> T6["家"] --> T7["领"] --> T8["导"] --> T9["人"]
    end

    %% DFA 匹配流程
    subgraph DFA["DFA 匹配流程"]
        direction TB
        DRoot((root))
        D台["台"] 
        D海["海"]
        D总["总"]
        D统["统\noutput:['台海总统']"]

        %% 树结构
        DRoot --> D台
        D台 --> D海
        D海 --> D总
        D总 --> D统
    end

    %% AC 匹配流程
    subgraph AC["AC 匹配流程"]
        direction TB
        ARoot((root))
        A台["台"] 
        A海["海"]
        A总["总"]
        A统["统\noutput:['台海总统']"]

        %% 树结构
        ARoot --> A台
        A台 --> A海
        A海 --> A总
        A总 --> A统

        %% fail 指针虚线
        A总 -.-> ARoot
        A海 -.-> ARoot
    end

    %% DFA 动画匹配箭头
    T0 -->|匹配 '台'| D台
    T1 -->|匹配 '海'| D海
    T2 -->|匹配 '总'| D总
    T3 -->|匹配 '统', output| D统
    D统 -->|记录匹配: '台海总统'| D统
    T4 -->|匹配失败 '是', 回到 root| DRoot

    %% AC 动画匹配箭头
    T0 -->|匹配 '台'| A台
    T1 -->|匹配 '海'| A海
    T2 -->|匹配 '总', 节点不存在? fail 回溯| ARoot
    ARoot -->|尝试 '总', 成功| A总
    T3 -->|匹配 '统', output| A统
    A统 -->|记录匹配: '台海总统'| A统
    T4 -->|匹配失败 '是', fail 回溯 root| ARoot
```
### AC vs DFA 匹配动画对比图特点
1. **DFA 匹配**：
    - 匹配失败必须 **回到 root**，然后从当前位置重新尝试。
    - 对于 `"是"`，DFA 需要回到 root，因此回溯次数较多。
2. **AC 匹配**：
    - 有 **fail 指针**，匹配失败不需要回到 root，直接跳到合适节点继续匹配。
    - 对于 `"总"` 和 `"是"`，AC 能利用 fail 指针减少回溯，匹配效率更高。
3. **动画箭头**：
    - 表示文本扫描过程中每个字符与树节点的匹配尝试。
    - output 节点表示敏感词匹配成功。

## 算法复杂度分析
###  DFA
- 构建复杂度：`O(L)`，`L` 为所有敏感词总长度
- 匹配复杂度：`O(T * M)`，`T` 为文本长度，`M` 为最长敏感词长度
- 空间复杂度：`O(L)`
- 特点：实现简单，但重复节点多，匹配长文本时效率低

### AC
- 构建复杂度：`O(L)`，包括 Trie 构建和 fail 指针构建
- 匹配复杂度：`O(T + k)`，`k` 为匹配到的敏感词总数
- 空间复杂度：`O(L)`
- 特点：利用 fail 指针快速回溯，单次扫描可匹配多词，高效且适合大量敏感词

### 对比总结
| 算法 | 构建复杂度 | 匹配复杂度 | 空间复杂度 | 特点                                         |
| ---- | ---------- | ---------- | ---------- | -------------------------------------------- |
| DFA  | O(L)       | O(T * M)   | O(L)       | 简单易实现，但效率受最长词影响大，重复节点多 |
| AC   | O(L)       | O(T + k)   | O(L)       | fail 指针优化回溯，可同时匹配多词，效率高    |

结论：
- 敏感词数量少、文本短 → DFA 可用
- 敏感词数量多、文本长或后缀重复 → AC 高效

## 总结
- DFA：
    - 简单直观，易于实现。
    - 路径独立，空间冗余大。
    - 匹配效率低，尤其是词库大时。
- AC：
    - 基于 DFA 增加 fail 指针和 output 列表。
    - 支持多词匹配和重叠词匹配。
    - 匹配失败回溯快，效率高，尤其适合大词库和高频文本匹配场景。